import os
import dbus
import re

from PyQt6.QtCore import QTimer, Qt
from PyQt6.QtGui import QFont, QPalette, QColor
from PyQt6.QtWidgets import (
    QScrollArea, QListWidgetItem, QGridLayout, QHBoxLayout, QVBoxLayout,
    QListWidget, QLabel, QLineEdit, QPushButton, QTableWidget, QTableWidgetItem,
    QTextBrowser, QWidget, QTextEdit, QTabWidget, QMessageBox, QFileDialog, QComboBox,
    QGroupBox # Import QGroupBox
)

# Assuming these imports are correct and available
from test_automation.UI.Backend_lib.Linux.filewatcher import BluezLogger
from test_automation.UI.UI_lib.controller_lib import Controller as LocalController  # Renamed to avoid conflict
from test_automation.UI.logger import Logger
from test_automation.UI.Backend_lib.Linux.a2dp_profile import A2DPManager
from test_automation.UI.Backend_lib.Linux.opp_profile import OPPManager
from test_automation.UI.Backend_lib.Linux.daemons import BluezServices


class Controller(LocalController): # Inherit from your existing Controller class
    pass


class TestApplication(QWidget):
    """
    Main GUI class for the Bluetooth Test Host.
    Handles Bluetooth discovery, pairing, connection (BR/EDR & LE), A2DP streaming,
    and media control operations using BlueZ and PulseAudio.
    """

    def __init__(self, interface=None, log_path=None, back_callback=None):
        super().__init__()
        self.log = Logger("UI")
        self.log_path = log_path
        self.bluez_logger = BluezLogger(self.log_path)
        self.interface = interface
        self.discovery_active = False
        self.back_callback = back_callback
        self.controller = Controller() # Use your custom Controller
        self.bluetooth_device_manager = BluezServices(interface=self.interface)
        self.a2dp_manager = A2DPManager(interface=self.interface)
        self.opp_manager = OPPManager()
        self.device_address_source = None
        self.device_address_sink = None

        self._setup_ui() # Call a central setup method

    def _setup_ui(self):
        """Central method to set up the entire UI."""
        self.main_grid_layout = QGridLayout()
        self.main_grid_layout.setSpacing(15) # Add overall spacing

        self._create_profiles_list()
        self._create_controller_details_section()
        self._create_profile_methods_area() # Renamed and structured
        self._create_log_viewers()
        self._create_back_button()

        self.setLayout(self.main_grid_layout)
        self.setWindowTitle("Bluetooth Test Host") # Set a window title
        self.setMinimumSize(1200, 700) # Set a minimum size

        # Apply global stylesheet (can be loaded from a .qss file too)
        self.setStyleSheet(self._get_global_stylesheet())
        # Select GAP by default and trigger its UI loading
        QTimer.singleShot(0, lambda: self.profiles_list_widget.setCurrentRow(0))


    def _get_global_stylesheet(self):
        return """
            QWidget {
                background-color: #eef2f5; /* Light background */
                color: #333333; /* Dark text */
                font-family: Arial, sans-serif;
                font-size: 10pt;
            }

            QLabel {
                color: #2c3e50; /* Darker labels */
            }

            QGroupBox {
                border: 1px solid #d0d0d0;
                border-radius: 5px;
                margin-top: 1.5ex; /* Space for title */
                font-size: 11pt;
                font-weight: bold;
                color: #2c3e50;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top left;
                padding: 0 3px;
                color: #3498db; /* Primary blue for group box titles */
            }

            QLineEdit {
                border: 1px solid #bdc3c7;
                border-radius: 4px;
                padding: 5px;
                background-color: white;
            }

            QPushButton {
                background-color: #3498db;
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
            QPushButton:pressed {
                background-color: #1a5276;
            }
            QPushButton:disabled {
                background-color: #bdc3c7;
                color: #7f8c8d;
            }

            QPushButton#onButton, QPushButton#startButton, QPushButton#refreshButton {
                background-color: #2ecc71; /* Green */
            }
            QPushButton#onButton:hover, QPushButton#startButton:hover, QPushButton#refreshButton:hover {
                background-color: #27ae60;
            }

            QPushButton#offButton, QPushButton#stopButton {
                background-color: #e74c3c; /* Red */
            }
            QPushButton#offButton:hover, QPushButton#stopButton:hover {
                background-color: #c0392b;
            }

            QListWidget {
                border: 1px solid #d0d0d0;
                background-color: white;
                border-radius: 5px;
            }
            QListWidget::item {
                padding: 5px;
                color: #333333;
            }
            QListWidget::item:selected {
                background-color: #3498db;
                color: white;
                border-radius: 3px;
            }

            QTableWidget {
                alternate-background-color: #f8f8f8; /* Very light gray */
                gridline-color: #e0e0e0;
                border: 1px solid #d0d0d0;
                border-radius: 5px;
            }
            QTableWidget::item {
                padding: 5px;
            }
            QHeaderView::section {
                background-color: #34495e; /* Darker header */
                color: white;
                padding: 8px;
                border: 1px solid #2c3e50;
                font-weight: bold;
            }

            QTabWidget::pane {
                border: 1px solid #d0d0d0;
                background: white;
                border-radius: 5px;
            }
            QTabBar::tab {
                background: #e0e0e0;
                color: #555555;
                padding: 8px 15px;
                border: 1px solid #d0d0d0;
                border-bottom: none;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
            }
            QTabBar::tab:selected {
                background: white;
                color: #3498db;
                border-color: #3498db;
                border-bottom-color: white; /* Hide bottom border to merge with pane */
                font-weight: bold;
            }
            QTabBar::tab:hover {
                background: #f0f0f0;
            }

            QTextEdit, QTextBrowser {
                background-color: white;
                border: 1px solid #d0d0d0;
                border-radius: 5px;
                color: #333333;
                padding: 8px;
            }
        """

    def _create_profiles_list(self):
        """Creates the 'List of Profiles' section."""
        profiles_group_box = QGroupBox("List of Profiles")
        profiles_layout = QVBoxLayout()
        profiles_group_box.setLayout(profiles_layout)

        self.profiles_list_widget = QListWidget()
        self.profiles_list_widget.addItem("GAP")
        self.profiles_list_widget.itemSelectionChanged.connect(self.profile_selected)
        profiles_layout.addWidget(self.profiles_list_widget)

        self.main_grid_layout.addWidget(profiles_group_box, 0, 0, 3, 1) # Span more rows for list

    def _create_controller_details_section(self):
        """Creates the 'Controller Details' section."""
        controller_group_box = QGroupBox("Controller Details")
        controller_details_layout = QVBoxLayout()
        controller_group_box.setLayout(controller_details_layout)

        self.bluez_logger.get_controller_details(interface=self.interface)
        # Populate controller object
        self.controller.name = self.bluez_logger.name
        self.controller.bd_address = self.bluez_logger.bd_address
        self.controller.link_policy = self.bluez_logger.link_policy
        self.controller.lmp_version = self.bluez_logger.lmp_version
        self.controller.link_mode = self.bluez_logger.link_mode
        self.controller.hci_version = self.bluez_logger.hci_version
        self.controller.manufacturer = self.bluez_logger.manufacturer

        details = {
            "Name": self.controller.name,
            "Address": self.controller.bd_address,
            "Link Mode": self.controller.link_mode,
            "Link Policy": self.controller.link_policy,
            "HCI Version": self.controller.hci_version,
            "LMP Version": self.controller.lmp_version,
            "Manufacturer": self.controller.manufacturer,
        }

        for label_text, value_text in details.items():
            h_layout = QHBoxLayout()
            label = QLabel(f"<b>{label_text}:</b>") # Use HTML for bold directly in QLabel
            value = QLabel(value_text)
            h_layout.addWidget(label)
            h_layout.addWidget(value)
            h_layout.addStretch(1) # Push values to left
            controller_details_layout.addLayout(h_layout)

        # controller_group_box.setFixedWidth(350) # Removed fixed width, let layout manage
        self.main_grid_layout.addWidget(controller_group_box, 3, 0, 5, 1) # Adjust row span

    def _create_profile_methods_area(self):
        """Creates the 'Profile Methods or Procedures' area."""
        profile_methods_group_box = QGroupBox("Profile Actions")
        self.profile_methods_layout = QVBoxLayout() # This will hold dynamically loaded content
        profile_methods_group_box.setLayout(self.profile_methods_layout)

        self.profile_description_text_browser = QTextBrowser()
        self.profile_description_text_browser.setMinimumHeight(50) # Give it some height
        self.profile_description_text_browser.setMaximumHeight(80) # Don't let it grow too much
        self.profile_description_text_browser.setText("Select a profile to view available actions.")
        self.profile_description_text_browser.setFont(QFont("Arial", 10)) # Consistent font

        self.profile_methods_layout.addWidget(self.profile_description_text_browser)

        # Placeholder widget for dynamically loaded profile methods (GAP, A2DP, OPP)
        self.profile_content_widget = QWidget()
        self.profile_methods_layout.addWidget(self.profile_content_widget)

        self.main_grid_layout.addWidget(profile_methods_group_box, 0, 1, 8, 2) # Adjust column/row span

    def _create_log_viewers(self):
        """Creates the 'Dump Logs' section."""
        dump_logs_group_box = QGroupBox("System Logs")
        dump_logs_layout = QVBoxLayout()
        dump_logs_group_box.setLayout(dump_logs_layout)

        self.dump_logs_text_browser = QTabWidget()
        dump_logs_layout.addWidget(self.dump_logs_text_browser)

        self.bluetoothd_log_text_browser = QTextEdit()
        self.bluetoothd_log_text_browser.setReadOnly(True)

        self.pulseaudio_log_text_browser = QTextEdit()
        self.pulseaudio_log_text_browser.setReadOnly(True)

        self.hci_dump_log_text_browser = QTextEdit()
        self.hci_dump_log_text_browser.setReadOnly(True)

        self.dump_logs_text_browser.addTab(self.bluetoothd_log_text_browser, "Bluetoothd")
        self.dump_logs_text_browser.addTab(self.pulseaudio_log_text_browser, "Pulseaudio")
        self.dump_logs_text_browser.addTab(self.hci_dump_log_text_browser, "HCI Dump")

        self.bluez_logger.start_bluetoothd_logs(self.bluetoothd_log_text_browser)
        self.bluez_logger.start_pulseaudio_logs(self.pulseaudio_log_text_browser)
        self.bluez_logger.start_dump_logs(
            interface=self.interface,
            log_text_browser=self.hci_dump_log_text_browser)

        self.main_grid_layout.addWidget(dump_logs_group_box, 0, 3, 8, 2) # Adjust column/row span

    def _create_back_button(self):
        """Creates the back button."""
        back_button = QPushButton("Back")
        back_button.setFixedSize(100, 35) # Slightly smaller, consistent with other buttons
        back_button.clicked.connect(self.back_callback)
        back_button_layout = QHBoxLayout()
        back_button_layout.addWidget(back_button)
        back_button_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        # Position at bottom left of log section, adjust column span if needed
        self.main_grid_layout.addLayout(back_button_layout, 8, 4, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignBottom)

    def show_discovery_table(self):
        """
        Display discovered devices in a table with options to pair or connect (BR/EDR, LE).
        """
        if hasattr(self, 'timer') and self.timer.isActive():
            self.timer.stop()

        bus = dbus.SystemBus()
        om = dbus.Interface(bus.get_object("org.bluez", "/"), "org.freedesktop.DBus.ObjectManager")
        objects = om.GetManagedObjects()
        devices = [path for path, interfaces in objects.items() if "org.bluez.Device1" in interfaces]

        # Clear existing table if any
        if hasattr(self, 'table_widget') and self.table_widget:
            self.gap_methods_layout.removeWidget(self.table_widget)
            self.table_widget.deleteLater()
            self.table_widget = None

        self.table_widget = QTableWidget(len(devices), 3)
        self.table_widget.setHorizontalHeaderLabels(["DEVICE NAME", "BD_ADDR", "ACTIONS"])
        self.table_widget.horizontalHeader().setStretchLastSection(True)
        self.table_widget.setAlternatingRowColors(True) # Enable alternating row colors

        for i, device_path in enumerate(devices):
            device = dbus.Interface(bus.get_object("org.bluez", device_path), dbus_interface="org.bluez.Device1")
            device_props = dbus.Interface(bus.get_object("org.bluez", device_path),
                                          dbus_interface="org.freedesktop.DBus.Properties")
            device_address = device_props.Get("org.bluez.Device1", "Address")
            device_name = device_props.Get("org.bluez.Device1", "Alias")

            self.table_widget.setItem(i, 0, QTableWidgetItem(device_name))
            self.table_widget.setItem(i, 1, QTableWidgetItem(device_address))

            button_widget = QWidget()
            button_layout = QHBoxLayout()
            button_layout.setContentsMargins(0, 0, 0, 0) # Remove internal padding for buttons

            pair_button = QPushButton("PAIR")
            pair_button.setObjectName("pairButton") # Use object name for specific styling
            pair_button.setMinimumSize(30, 20)
            pair_button.setMaximumHeight(30) # Fixed height for consistency
            button_layout.addWidget(pair_button)

            br_edr_connect_button = QPushButton("BR/EDR Connect") # More descriptive label
            br_edr_connect_button.setObjectName("brEdrConnectButton")
            br_edr_connect_button.setMinimumSize(30, 20)
            br_edr_connect_button.setMaximumHeight(30)
            button_layout.addWidget(br_edr_connect_button)

            le_connect_button = QPushButton("LE Connect") # More descriptive label
            le_connect_button.setObjectName("leConnectButton")
            le_connect_button.setMinimumSize(30, 20)
            le_connect_button.setMaximumHeight(30)
            button_layout.addWidget(le_connect_button)

            button_widget.setLayout(button_layout)
            self.table_widget.setCellWidget(i, 2, button_widget)

            pair_button.clicked.connect(lambda checked, address=device_address: self.handle_device_action('pair', address))
            br_edr_connect_button.clicked.connect(lambda checked, address=device_address: self.handle_device_action('br_edr_connect', address))
            le_connect_button.clicked.connect(lambda checked, address=device_address: self.handle_device_action('le_connect', address))

        # Add the table to the GAP layout
        self.gap_methods_layout.addWidget(self.table_widget)
        self.table_widget.resizeColumnsToContents() # Auto-resize columns
        self.set_discovery_off_button.setEnabled(False) # This should remain false after showing table

    # Removed build_a2dp_source_tab and build_a2dp_sink_tab
    # as their logic will be integrated into _build_consolidated_a2dp_panel

    def _build_consolidated_a2dp_panel(self, device_address):
        """
        Builds a single A2DP panel combining source streaming and sink media control,
        based on the device's A2DP roles.
        """
        layout = QVBoxLayout()
        layout.setSpacing(10)

        a2dp_label = QLabel("<b>A2DP Functionality:</b>")
        layout.addWidget(a2dp_label)

        self.device_address_source = device_address # Assume the selected device is both source/sink for the UI
        self.device_address_sink = device_address # Set this for media control

        role = self.get_a2dp_role_for_device(device_address)

        if role in ["sink", "both"]:
            # A2DP Source (streaming to this device)
            streaming_group = QGroupBox("Streaming Audio (A2DP Source)")
            streaming_layout = QVBoxLayout()
            streaming_group.setLayout(streaming_layout)

            audio_layout = QHBoxLayout()
            audio_layout.addWidget(QLabel("Audio File:"))
            self.audio_location_input = QLineEdit()
            self.audio_location_input.setReadOnly(True)
            audio_layout.addWidget(self.audio_location_input)
            self.browse_audio_button = QPushButton("Browse...")
            self.browse_audio_button.clicked.connect(self.browse_audio_file)
            audio_layout.addWidget(self.browse_audio_button)
            streaming_layout.addLayout(audio_layout)

            streaming_buttons_layout = QHBoxLayout()
            self.start_streaming_button = QPushButton("Start Streaming")
            self.start_streaming_button.setObjectName("startButton")
            self.start_streaming_button.clicked.connect(self.start_streaming)
            streaming_buttons_layout.addWidget(self.start_streaming_button)

            self.stop_streaming_button = QPushButton("Stop Streaming")
            self.stop_streaming_button.setObjectName("stopButton")
            self.stop_streaming_button.clicked.connect(self.stop_streaming)
            self.stop_streaming_button.setEnabled(False)
            streaming_buttons_layout.addWidget(self.stop_streaming_button)
            streaming_layout.addLayout(streaming_buttons_layout)

            layout.addWidget(streaming_group)


        if role in ["source", "both"]:
            # A2DP Sink (controlling this device's media)
            media_control_group = QGroupBox("Media Control (A2DP Sink)")
            media_control_layout = QVBoxLayout()
            media_control_group.setLayout(media_control_layout)

            control_buttons = QHBoxLayout()
            self.play_button = QPushButton("Play")
            self.play_button.clicked.connect(self.play)
            control_buttons.addWidget(self.play_button)

            self.pause_button = QPushButton("Pause")
            self.pause_button.clicked.connect(self.pause)
            control_buttons.addWidget(self.pause_button)

            self.next_button = QPushButton("Next")
            self.next_button.clicked.connect(self.next)
            control_buttons.addWidget(self.next_button)

            self.previous_button = QPushButton("Previous")
            self.previous_button.clicked.connect(self.previous)
            control_buttons.addWidget(self.previous_button)

            self.rewind_button = QPushButton("Rewind")
            self.rewind_button.clicked.connect(self.rewind)
            control_buttons.addWidget(self.rewind_button)

            media_control_layout.addLayout(control_buttons)
            layout.addWidget(media_control_group)

        widget = QWidget()
        widget.setLayout(layout)
        return widget


    def get_a2dp_role_for_device(self, device_address):
        sinks = self.a2dp_manager.get_connected_a2dp_sink_devices()
        sources = self.a2dp_manager.get_connected_a2dp_source_devices()

        if device_address in sinks and device_address in sources:
            return "both"
        elif device_address in sinks:
            return "sink" # This means the local device acts as source, sending to the remote device as sink
        elif device_address in sources:
            return "source" # This means the local device acts as sink, receiving from the remote device as source
        return None

    def browse_audio_file(self):
        """Open a file dialog for selecting an audio file."""
        file_dialog = QFileDialog()
        file_path, _ = file_dialog.getOpenFileName(None, "Select Audio File", "",
                                                   "Audio Files (*.mp3 *.wav *.ogg *.flac);;All Files (*)")
        if file_path:
            self.audio_location_input.setText(file_path)

    # ... (Your existing A2DP start_streaming, stop_streaming, play, pause, next, previous, rewind methods remain the same) ...
    def start_streaming(self):
        """
        Start A2DP streaming to a selected Bluetooth sink device.
        Validates file and device selection.

        args:None
        returns: None

        """

        audio_path = self.audio_location_input.text().strip()
        if not audio_path or not os.path.exists(audio_path):
            QMessageBox.warning(self, "Invalid Audio File", "Please select a valid audio file to stream.")
            return

        print(f"Selected device address for streaming: {self.device_address_source}")

        if not self.device_address_source:
            QMessageBox.warning(self, "No Device", "Please select a Bluetooth sink device to stream.")
            return

        print(f"A2DP streaming started with file: {audio_path}")

        self.start_streaming_button.setEnabled(False)
        self.stop_streaming_button.setEnabled(True)

        # Create BluetoothDeviceManager instance and start streaming
        success = self.a2dp_manager.start_streaming(self.device_address_source, audio_path)

        if not success:
            QMessageBox.critical(self, "Streaming Failed", "Failed to start streaming.")
            self.start_streaming_button.setEnabled(True)
            self.stop_streaming_button.setEnabled(False)

    def stop_streaming(self):
        """
        Stop active A2DP streaming session.

        args: None
        returns: None
        """
        print("A2DP streaming stopped")
        self.start_streaming_button.setEnabled(True)
        self.stop_streaming_button.setEnabled(False)

        self.a2dp_manager.stop_streaming()

        if hasattr(self, 'streaming_timer'):
            self.streaming_timer.stop()

    def play(self):
        """
        Send media play command to sink device.

        args: None
        returns: None
        """
        print("Play button has been pressed")
        print(f"device_address_sink = {self.device_address_sink}")  # Debugging line
        if self.device_address_sink:
            self.a2dp_manager.play(self.device_address_sink)
        else:
            QMessageBox.warning(self, "No Device", "Please select a sink device for media control.")

    def pause(self):
        """
        Send media pause command to sink device.

        args : None
        returns: None
        """
        print("Pause button has been pressed")
        print(f"device_address_sink = {self.device_address_sink}")
        if self.device_address_sink:
            self.a2dp_manager.pause(self.device_address_sink)
        else:
            QMessageBox.warning(self, "No Device", "Please select a sink device for media control.")

    def next(self):
        """
        Send media next track command to sink device.

        args : None
        returns: None
        """

        print(f"Next button has been pressed. Device address: {self.device_address_sink}")  # Debugging line
        if self.device_address_sink:
            self.a2dp_manager.next(self.device_address_sink)
        else:
            QMessageBox.warning(self, "No Device", "Please select a sink device for media control.")

    def previous(self):
        """
        Handle media control action: Previous track.

        args: None
        returns: None
        """
        print(f"Previous button has been pressed. Device address: {self.device_address_sink}")  # Debugging line
        if self.device_address_sink:
            self.a2dp_manager.previous(self.device_address_sink)
        else:
            QMessageBox.warning(self, "No Device", "Please select a sink device for media control.")

    def rewind(self):
        """Handle media control action: Rewind track.

        args: None
        returns: None
        """
        print(f"Rewind button has been pressed. Device address: {self.device_address_sink}")  # Debugging line
        if self.device_address_sink:
            self.a2dp_manager.rewind(self.device_address_sink)
        else:
            QMessageBox.warning(self, "No Device", "Please select a sink device for media control.")

    # Removed refresh_a2dp_sink_devices, on_device_selected_for_a2dp, on_device_selected_for_a2dp_sink
    # These are no longer needed as the selection is now implicit from the main device list

    def browse_opp_file(self):
        """
        Open a file dialog to select a file to send via OPP.

        args: None
        returns: None
        """

        file_dialog = QFileDialog()
        file_path, _ = file_dialog.getOpenFileName(
            None,
            "Select File to Send via OPP",
            "",
            "All Files (*)"
        )
        if file_path:
            self.opp_location_input.setText(file_path)

    def send_file(self):
        """
        Send a selected file to a remote device using OPP.

        args: None
        returns: None
        """

        file_path = self.opp_location_input.text()
        # device_index = self.device_selector.currentIndex() # Removed combobox
        # device_address = self.device_selector.itemData(device_index) # Removed combobox
        device_address = self.device_address # Use the current selected device

        if not file_path or not device_address:
            QMessageBox.warning(None, "OPP", "Please select a device and a file.")
            return

        self.send_file_button.setEnabled(False)
        self.send_file_button.setText("Sending...")

        try:
            success = self.opp_manager.send_file_via_obex(device_address, file_path)
        except Exception as e:
            success = False
            print(f"UI error: {e}")

        self.send_file_button.setEnabled(True)
        self.send_file_button.setText("Send File")

        if success is True:
            QMessageBox.information(None, "OPP", "File sent successfully!")
        else:
            QMessageBox.warning(None, "OPP",
                                "Notification has been sent to the remote device, accept it to receive the object")

    def receive_file(self):
        """
        Start OPP receiver to receive files from a remote device.

        args: None
        returns: None
        """

        success = self.opp_manager.start_opp_receiver()
        QMessageBox.information(None, "OPP", "Ready to receive files..." if success else "Failed to start receiver.")


    def build_opp_tab(self):
        """
        Builds the OPP panel.
        """
        layout = QVBoxLayout()
        layout.setSpacing(10)

        opp_label = QLabel("<b>OPP Functionality:</b>")
        layout.addWidget(opp_label)

        # Removed redundant device selector here
        device_info_label = QLabel(f"Connected Device: {self.device_address}")
        layout.addWidget(device_info_label)

        # File selection
        file_selection_layout = QHBoxLayout()
        file_selection_layout.addWidget(QLabel("File to Send:"))
        self.opp_location_input = QLineEdit()
        self.opp_location_input.setReadOnly(True)
        file_selection_layout.addWidget(self.opp_location_input)
        self.browse_opp_button = QPushButton("Browse...")
        self.browse_opp_button.clicked.connect(self.browse_opp_file)
        file_selection_layout.addWidget(self.browse_opp_button)
        layout.addLayout(file_selection_layout)

        # Send and Receive buttons
        button_layout = QHBoxLayout()
        self.send_file_button = QPushButton("Send File")
        self.send_file_button.clicked.connect(self.send_file)
        button_layout.addWidget(self.send_file_button)

        self.receive_file_button = QPushButton("Receive File")
        self.receive_file_button.clicked.connect(self.receive_file)
        button_layout.addWidget(self.receive_file_button)

        layout.addLayout(button_layout)

        widget = QWidget()
        widget.setLayout(layout)
        return widget


#-------------PROFILE TABS GENERATION-----------------------------
    def load_profile_tabs_for_device(self, device_address):
        # bold_font = QFont() # Not strictly needed if using CSS/HTML bold
        # bold_font.setBold(True)

        # if hasattr(self, 'profile_methods_widget'): # This is handled by clear_layout(self.profile_content_widget) now
        #     self.profile_methods_widget.setParent(None)

        self.device_address = device_address # Store the device address

        self.profile_description_text_browser.setText(f"Connected Device: <b>{device_address}</b><br>Select a profile to proceed (A2DP or OPP)")

        # Create empty tabs for A2DP and OPP
        self.device_tab_widget = QTabWidget()
        # self.device_tab_widget.setFont(bold_font) # Font will be inherited from global stylesheet
        # self.device_tab_widget.setStyleSheet("color: black; background-color: lightblue;") # Handled by global stylesheet

        # Empty widgets that will be filled when the tab is clicked
        self.a2dp_tab_placeholder = QWidget()
        self.opp_tab_placeholder = QWidget()

        self.device_tab_widget.addTab(self.a2dp_tab_placeholder, "A2DP")
        self.device_tab_widget.addTab(self.opp_tab_placeholder, "OPP")


        self.device_tab_widget.currentChanged.connect(self.on_profile_tab_changed)

        # Add the tab widget to the profile_content_widget
        self.profile_content_widget.setLayout(QVBoxLayout())
        self.profile_content_widget.layout().addWidget(self.device_tab_widget)

        # Manually trigger the tab setup for the default (usually first) tab
        QTimer.singleShot(0, lambda: self.on_profile_tab_changed(self.device_tab_widget.currentIndex()))

#---------PROFILE TAB SELECTION-----------------------------
    def on_profile_tab_changed(self, index):
        if not hasattr(self, 'device_tab_widget') or index < 0:
            return  # Prevent early or invalid calls

        selected_tab = self.device_tab_widget.tabText(index)
        print(f"Switched to tab: {selected_tab}")

        # Ensure we're clearing the correct placeholder
        if selected_tab == "A2DP":
            self.clear_layout(self.a2dp_tab_placeholder)
            layout = QVBoxLayout()
            # Build the consolidated A2DP panel directly
            a2dp_panel = self._build_consolidated_a2dp_panel(self.device_address)
            layout.addWidget(a2dp_panel)
            self.a2dp_tab_placeholder.setLayout(layout)
            self.a2dp_tab_placeholder.update()

        elif selected_tab == "OPP":
            self.clear_layout(self.opp_tab_placeholder)
            layout = QVBoxLayout()
            opp_tab = self.build_opp_tab()
            layout.addWidget(opp_tab)
            self.opp_tab_placeholder.setLayout(layout)
            self.opp_tab_placeholder.update()


    def clear_layout(self, widget):
        layout = widget.layout()
        if layout is not None:
            while layout.count():
                child = layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            # It's important to set the layout to None or a new empty layout
            # otherwise, trying to add a new layout to the same widget will fail
            # Setting layout to QWidget() is a trick to detach and clean up
            QWidget().setLayout(layout) # Detach old layout
            widget.setLayout(QVBoxLayout()) # Set a new empty layout for future content


#---------CONNECTED/PAIRED DEVICE ADDED BELOW GAP---------

    def add_device(self, device_address):
        """
        Adds a device address below the GAP item in the profile list if not already present.
        Args:
            device_address (str): The paired/connected device MAC address (e.g., 20:32:C6:7B:91:1C)
        """
        # Find GAP index
        gap_index = -1
        for i in range(self.profiles_list_widget.count()):
            if self.profiles_list_widget.item(i).text().strip() == "GAP":
                gap_index = i
                break
        if gap_index == -1:
            return  # GAP not found, should not happen

        # Check if device is already added
        for i in range(self.profiles_list_widget.count()):
            if self.profiles_list_widget.item(i).text().strip() == device_address:
                return  # Already added

        # Add device address as a new list item right after GAP
        device_item = QListWidgetItem(device_address)
        # device_item.setFont(QFont("Arial", 10)) # Font from global stylesheet
        # device_item.setForeground(Qt.GlobalColor.black) # Color from global stylesheet

        self.profiles_list_widget.insertItem(gap_index + 1, device_item)


#------CHECK IF IT IS VALID BLUETOOTH ADDRESS-------
    def is_bluetooth_address(self, text):
        pattern = r"^[0-9A-Fa-f]{2}(:[0-9A-Fa-f]{2}){5}$"
        return re.match(pattern, text) is not None

#------PROFILE SELECTION----------------
    def profile_selected(self):
        """
         Handles profile selection from the list.

         Depending on the selected Bluetooth profile (e.g., GAP, A2DP, OPP),
         this function dynamically updates the GUI to show relevant methods,
         controls, and input fields for the selected profile.

         args: None
         returns: None
         """
        selected_item = self.profiles_list_widget.currentItem()
        if not selected_item:
            return

        selected_item_text = selected_item.text().strip()

        # Clear existing content in the profile methods area
        self.clear_layout(self.profile_content_widget)


        if self.is_bluetooth_address(selected_item_text):
            self.load_profile_tabs_for_device(selected_item_text)
        elif selected_item_text == "GAP":
            self.profile_description_text_browser.setText("<b>GAP Profile Selected:</b><br>Use the methods below for Bluetooth General Access Profile operations.")

            gap_container_layout = QVBoxLayout() # A layout to hold GAP group boxes
            gap_container_layout.setSpacing(10) # Spacing between GAP sections

            # Set Discoverable Group
            discoverable_group = QGroupBox("Set Discoverable")
            discoverable_layout = QVBoxLayout()
            discoverable_group.setLayout(discoverable_layout)

            timeout_layout = QHBoxLayout()
            timeout_layout.addWidget(QLabel("Timeout (seconds):"))
            self.discoverable_timeout_input = QLineEdit("0")
            timeout_layout.addWidget(self.discoverable_timeout_input)
            discoverable_layout.addLayout(timeout_layout)

            buttons_layout = QHBoxLayout()
            self.set_discoverable_on_button = QPushButton("ON")
            self.set_discoverable_on_button.setObjectName("onButton") # For styling
            self.set_discoverable_on_button.clicked.connect(self.set_discoverable_on)
            buttons_layout.addWidget(self.set_discoverable_on_button)

            self.set_discoverable_off_button = QPushButton("OFF")
            self.set_discoverable_off_button.setObjectName("offButton") # For styling
            self.set_discoverable_off_button.clicked.connect(self.set_discoverable_off)
            self.set_discoverable_on_button.setEnabled(True)
            self.set_discoverable_off_button.setEnabled(False)
            buttons_layout.addWidget(self.set_discoverable_off_button)
            discoverable_layout.addLayout(buttons_layout)

            self.refresh_button_discoverable = QPushButton("Refresh Timeout")
            self.refresh_button_discoverable.clicked.connect(self.refresh_discoverable)
            discoverable_layout.addWidget(self.refresh_button_discoverable)
            gap_container_layout.addWidget(discoverable_group)

            # Inquiry (Discovery) Group
            inquiry_group = QGroupBox("Device Discovery")
            inquiry_layout = QVBoxLayout()
            inquiry_group.setLayout(inquiry_layout)

            inquiry_timeout_layout = QHBoxLayout()
            inquiry_timeout_layout.addWidget(QLabel("Timeout (seconds):"))
            self.inquiry_timeout_input = QLineEdit("0")
            inquiry_timeout_layout.addWidget(self.inquiry_timeout_input)
            inquiry_layout.addLayout(inquiry_timeout_layout)

            discovery_buttons_layout = QHBoxLayout()
            self.set_discovery_on_button = QPushButton("Start Discovery")
            self.set_discovery_on_button.setObjectName("startButton") # For styling
            self.set_discovery_on_button.clicked.connect(self.set_discovery_on)
            discovery_buttons_layout.addWidget(self.set_discovery_on_button)

            self.set_discovery_off_button = QPushButton("Stop Discovery")
            self.set_discovery_off_button.setObjectName("stopButton") # For styling
            self.set_discovery_off_button.clicked.connect(self.set_discovery_off)
            self.set_discovery_off_button.setEnabled(False) # Initially disabled
            discovery_buttons_layout.addWidget(self.set_discovery_off_button)
            inquiry_layout.addLayout(discovery_buttons_layout)

            self.refresh_button = QPushButton("Clear Discovery Results") # More descriptive
            self.refresh_button.clicked.connect(self.refresh)
            inquiry_layout.addWidget(self.refresh_button)
            gap_container_layout.addWidget(inquiry_group)

            self.gap_methods_layout = QVBoxLayout() # This will be the layout for the table
            gap_container_layout.addLayout(self.gap_methods_layout) # Add table layout below groups

            self.profile_content_widget.setLayout(gap_container_layout)
            self.profile_content_widget.update()

    # --- (Other methods like handle_device_action, pair, br_edr_connect, le_connect, refresh, refresh_discoverable remain unchanged) ---
    def handle_device_action(self, action, address):
        """
        Handle user-selected action (pair/BR-EDR/LE connect) for a device.

        Args:
            action (str): Action to perform.
            address (str): Bluetooth device address.

        returns:
            None
        """

        self.device_address = address
        if action == 'pair':
            self.pair(address)
        elif action == 'br_edr_connect':
            self.br_edr_connect(address)
        elif action == 'le_connect':
            self.le_connect(address)

    def refresh(self):
        """
        Refresh and clear the device discovery table.

        args: None
        returns: None
        """

        print("Refresh Button is pressed")
        if hasattr(self, 'table_widget') and self.table_widget:
            self.gap_methods_layout.removeWidget(self.table_widget)
            self.table_widget.deleteLater()
            self.table_widget = None
            self.inquiry_timeout_input.setText("0")
            self.refresh_button.setEnabled(False)
            self.set_discovery_on_button.setEnabled(True)
            self.set_discovery_off_button.setEnabled(False)
            self.refresh_button.setEnabled(True)

    def refresh_discoverable(self):
        """
        Reset discoverable timeout input to default (0).

        args: None
        returns: None
        """
        print("Discoverable refresh button is pressed")
        self.discoverable_timeout_input.setText("0")


    def pair(self, device_address):
        """
        Attempt to pair with the given Bluetooth device.

        Args:
            device_address (str): Bluetooth MAC address.
        """
        print(f"Attempting to pair with {device_address}")

        # Check if already paired
        if self.bluetooth_device_manager.is_device_paired(device_address):
            QMessageBox.information(self, "Already Paired", f"{device_address} is already paired.")
            self.add_device(device_address)
            return

        # This will block until confirmation is handled
        success = self.bluetooth_device_manager.pair(device_address)

        if success:
            QMessageBox.information(self, "Pairing Result", f"Pairing with {device_address} was successful.")
            self.add_device(device_address)
        else:
            QMessageBox.critical(self, "Pairing Failed", f"Pairing with {device_address} failed.")

    def br_edr_connect(self, device_address):
        """
        Connect to a device using BR/EDR.

        Args:
            device_address (str): Bluetooth MAC address.
        returns:
            None
        """

        print(f"Attempting BR/EDR connect with {device_address}")
        success = self.bluetooth_device_manager.br_edr_connect(device_address)
        if success:
            QMessageBox.information(self, "Connection Result", f"Connection with {device_address} was successful.")
            self.add_device(device_address)
        else:
            QMessageBox.critical(self, "Connection Failed", f"Connection with {device_address} failed.")

    def le_connect(self, device_address):
        """
        Connect to a device using LE (Low Energy).

        Args:
            device_address (str): Bluetooth MAC address.
        returns:
            None
        """

        print("LE_Connect is ongoing ")
        self.bluetooth_device_manager.le_connect(device_address)


